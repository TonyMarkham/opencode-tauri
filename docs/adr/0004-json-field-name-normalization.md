# ADR-0004: JSON Field Name Normalization via Build-Time Code Generation

**Status:** Accepted

**Date:** 2026-01-07

**Deciders:** Tony (project owner), AI assistants (research and analysis)

**Context Owners:** Backend team (client-core)

---

## Context

OpenCode server returns JSON with JavaScript-style field naming conventions, while our protobuf/Rust layer expects standard snake_case. This creates a systematic mismatch affecting 50+ fields across all OpenCode types.

### The Problem

| OpenCode JSON | Standard Protobuf | Issue |
|---------------|-------------------|-------|
| `projectID` | `project_id` | Uppercase acronym "ID" |
| `sessionID` | `session_id` | Uppercase acronym "ID" |
| `messageID` | `message_id` | Uppercase acronym "ID" |
| `baseURL` | `base_url` | Uppercase acronym "URL" |
| `cacheRead` | `cache_read` | Standard camelCase |

The critical issue is **uppercase acronyms**. Standard case-conversion libraries (e.g., `heck`, `convert_case`) produce incorrect results:

- Input: `projectID`
- Expected: `project_id`
- Actual (standard algorithms): `project_i_d` (treats each uppercase letter as a word boundary)

### Fields Affected

**Acronym fields (require special handling):**
- `*ID` fields: `projectID`, `sessionID`, `messageID`, `providerID`, `modelID`, `parentID`, `partID`, `callID`, `requestID` (9 unique)
- `*URL` fields: `baseURL` (1 unique)

**Edge cases (require explicit overrides):**
- `enterpriseUrl` - uses mixed "Url" not "URL"
- `experimentalOver200K` - numeric suffix with "K"
- `topP` - single letter suffix

**Standard camelCase (algorithm handles correctly):**
- `cacheRead`, `cacheWrite`, `reasoningEffort`, `serviceTier`, `maxToolCalls`, etc. (15+ fields)

### Two Surfaces Requiring Transformation

1. **Receiving from OpenCode (HTTP responses):** `projectID` → `project_id` before deserializing to proto types
2. **Sending to OpenCode (HTTP requests):** `project_id` → `projectID` before serializing request bodies

Both directions must use the same field mapping to ensure consistency.

**Universal Constraints (applies to all ADRs):**

- **Zero Custom JavaScript Policy** ([NO_CUSTOM_JAVASCRIPT_POLICY.md](./NO_CUSTOM_JAVASCRIPT_POLICY.md)): Not applicable to this decision (Rust-only).

- **Thin Tauri Layer Principle** ([ADR-0002](./0002-thin-tauri-layer-principle.md)): This normalization lives in `client-core`, not Tauri. Tauri remains a thin webview host.

- **WebSocket + Protobuf IPC** ([ADR-0003](./0003-websocket-protobuf-ipc.md)): Normalization happens at the HTTP boundary (client-core ↔ OpenCode server), before data enters the protobuf layer.

## Decision

Implement **build-time code generation** for JSON field name normalization:

1. **Configuration file** (`client-core/opencode_fields.toml`) defines acronym rules and explicit overrides
2. **Build script** (`client-core/build.rs`) reads the config and generates Rust code
3. **Generated code** contains bidirectional lookup tables and recursive JSON transformation functions
4. **No runtime config parsing** - all validation happens at compile time

### Configuration Format

```toml
# client-core/opencode_fields.toml
# Source of truth for OpenCode JSON ↔ Protobuf field name mappings

# Acronyms that stay together as single units
# "projectID" → "project_id" (not "project_i_d")
acronyms = ["ID", "URL"]

# Explicit overrides for edge cases
# NOTE: Overrides always take precedence over acronym rules
[overrides]
"enterpriseUrl" = "enterprise_url"
"experimentalOver200K" = "experimental_over_200_k"
"topP" = "top_p"
```

### Generated Code Structure

```rust
// Generated by build.rs - DO NOT EDIT

/// JavaScript field name → snake_case field name
static TO_SNAKE: Lazy<HashMap<&'static str, &'static str>> = Lazy::new(|| {
    let mut m = HashMap::with_capacity(52);
    m.insert("projectID", "project_id");
    m.insert("sessionID", "session_id");
    // ... all mappings generated from acronym rules + overrides
    m
});

/// snake_case field name → JavaScript field name  
static TO_JS: Lazy<HashMap<&'static str, &'static str>> = Lazy::new(|| {
    // ... reverse mappings
});

pub fn normalize_key(key: &str) -> Cow<'_, str>;
pub fn denormalize_key(key: &str) -> Cow<'_, str>;
pub fn normalize_json(value: serde_json::Value) -> serde_json::Value;
pub fn denormalize_json(value: serde_json::Value) -> serde_json::Value;
```

### Integration Point

```rust
// client-core/src/opencode_client.rs

impl OpencodeClient {
    async fn get<T: DeserializeOwned>(&self, path: &str) -> Result<T, Error> {
        let json: Value = self.http.get(path).await?.json().await?;
        let normalized = normalize_json(json);  // Generated function
        Ok(serde_json::from_value(normalized)?)
    }
    
    async fn post<T: Serialize, R: DeserializeOwned>(&self, path: &str, body: &T) -> Result<R, Error> {
        let json = serde_json::to_value(body)?;
        let denormalized = denormalize_json(json);  // Generated function
        let response_json: Value = self.http.post(path).json(&denormalized).await?.json().await?;
        let normalized = normalize_json(response_json);
        Ok(serde_json::from_value(normalized)?)
    }
}
```

## Alternatives Considered

### Alternative 1: prost-build field_attribute()

**Description:** Add `#[serde(rename = "projectID")]` to each proto field via prost-build configuration.

```rust
// build.rs
config.field_attribute("OcSessionInfo.project_id", r#"#[serde(rename = "projectID")]"#);
// ... 50+ more lines
```

**Pros:**
- No runtime transformation
- Works with standard serde

**Cons:**
- 50+ manual field_attribute() calls
- Must update build.rs for every new field
- Easy to miss fields (silent failures)
- Pollutes proto types with serde attributes

**Why rejected:** High maintenance burden, scattered configuration, no single source of truth.

### Alternative 2: pbjson Crate

**Description:** Use pbjson to generate serde implementations for proto types.

**Pros:**
- Handles protobuf JSON mapping spec
- Active maintenance

**Cons:**
- Generates standard camelCase (`projectId`), not JavaScript-style (`projectID`)
- No support for custom field renaming
- Would require forking the crate

**Why rejected:** Fundamentally incompatible with OpenCode's naming convention.

### Alternative 3: Intermediate Wire Structs

**Description:** Create separate Rust structs that match OpenCode JSON exactly, with explicit `#[serde(rename)]` attributes, then convert to/from proto types.

```rust
mod wire {
    #[derive(Deserialize)]
    pub struct SessionInfo {
        #[serde(rename = "projectID")]
        pub project_id: String,
        // ... all fields with renames
    }
}

impl From<wire::SessionInfo> for proto::OcSessionInfo { ... }
```

**Pros:**
- Full control over JSON structure
- Proven pattern (used by opencode-egui)

**Cons:**
- 2x struct definitions (wire + proto)
- Manual From/Into implementations
- High duplication and drift risk

**Why rejected:** Excessive boilerplate, maintenance burden.

### Alternative 4: Runtime Config-Driven Normalizer

**Description:** Load TOML config at runtime, transform JSON keys dynamically.

```rust
static NORMALIZER: Lazy<Normalizer> = Lazy::new(|| {
    Normalizer::from_toml(include_str!("../opencode_fields.toml")).unwrap()
});
```

**Pros:**
- Single source of truth
- Clean separation

**Cons:**
- Config errors caught at runtime, not compile time
- Runtime panic if config is invalid
- Slightly higher startup cost

**Why rejected:** Build-time generation provides compile-time validation with no runtime cost.

### Alternative 5: Custom Serde Deserializer

**Description:** Implement custom `Deserialize` for each type with field name transformation logic.

**Pros:**
- No separate transformation step

**Cons:**
- Complex manual Visitor implementations
- Must write for every type
- Error-prone, hard to maintain

**Why rejected:** Excessive complexity, doesn't scale.

## Consequences

### Positive

- **Single source of truth:** All field mappings defined in one TOML file
- **Compile-time validation:** Invalid config fails the build, not runtime
- **Zero runtime config parsing:** Config is baked into generated code
- **Clean proto types:** No serde attributes polluting generated proto code
- **Bidirectional:** Same config handles both request and response transformation
- **Maintainable:** Adding a new acronym or override is a one-line change

### Negative

- **Build complexity:** build.rs now has two responsibilities (proto compilation + normalizer generation)
- **Runtime cost:** JSON tree traversal on every HTTP request/response (mitigated: fast HashMap lookups, typically small payloads)
- **Generated code:** Another file in OUT_DIR to understand

### Neutral

- **Dependency on serde_json::Value:** Already required for dynamic JSON handling
- **HashMap lookups:** O(1) per field, negligible overhead

## Implementation Notes

### Build Script Structure

```rust
// build.rs
fn main() {
    // Existing: compile protobufs
    compile_protos();
    
    // New: generate field normalizer
    generate_field_normalizer();
}

fn generate_field_normalizer() {
    let config = parse_toml("opencode_fields.toml");
    let mappings = expand_acronym_rules(&config);
    let code = generate_rust_code(&mappings);
    write_to_out_dir("field_normalizer.rs", &code);
    
    println!("cargo:rerun-if-changed=opencode_fields.toml");
}
```

### Acronym Expansion Algorithm

For each known field ending with an acronym:
1. Find acronym at end of camelCase identifier (e.g., "ID" in "projectID")
2. Split into words: ["project", "ID"]
3. Convert to snake_case: "project_id"
4. Generate bidirectional mapping

**Precedence rule:** Explicit overrides always win over acronym expansion. If a field appears in `[overrides]`, the acronym rules are not applied to it.

### Build-Time Validation

The build script must validate:
1. **No duplicate JS keys:** No two entries map from the same JavaScript field name
2. **No duplicate snake_case keys:** No two entries map to the same snake_case field name
3. **Round-trip safety:** For every mapping `a → b`, there must be a reverse mapping `b → a`

If any validation fails, the build fails with a clear error message. This prevents silent configuration mistakes.

### Testing Strategy

1. **Unit tests:** Test individual key transformations
2. **Round-trip tests:** Verify `denormalize(normalize(json)) == json`
3. **Integration tests:** Use real OpenCode JSON samples from schema files
4. **Compile-time validation:** Build fails if config is malformed

**Debug assertion hook (optional):**
```rust
#[cfg(debug_assertions)]
pub fn assert_round_trip(value: &serde_json::Value) {
    let normalized = normalize_json(value.clone());
    let denormalized = denormalize_json(normalized);
    assert_eq!(denormalized, *value, "Round-trip failed");
}
```

### Files to Create/Modify

| File | Action | Purpose |
|------|--------|---------|
| `client-core/opencode_fields.toml` | Create | Configuration source of truth |
| `client-core/build.rs` | Modify | Add normalizer code generation |
| `client-core/src/lib.rs` | Modify | Include generated code |
| `client-core/src/opencode_client.rs` | Create | HTTP client using normalizer |

## References

- [heck crate](https://crates.io/crates/heck) - Case conversion library (doesn't handle our acronym case)
- [convert_case crate](https://crates.io/crates/convert_case) - Alternative case conversion (same limitation)
- [Protobuf JSON Mapping](https://developers.google.com/protocol-buffers/docs/proto3#json) - Standard says `projectId`, OpenCode uses `projectID`
- [prost-build field_attribute](https://docs.rs/prost-build/latest/prost_build/struct.Config.html#method.field_attribute) - Alternative considered
- [pbjson crate](https://crates.io/crates/pbjson) - Alternative considered
- OpenCode JSON schemas: `submodules/opencode/schema/*.schema.json` - Source of field naming truth
